我将按照以下详细规范实现格式刷功能：

### 1. 样式捕获清单 (Capture Strategy)
我将从源选区捕获以下三类样式数据：

**A. 基础格式 (Boolean States)**
*   **加粗** (`bold`)
*   **斜体** (`italic`)
*   **下划线** (`underline`)
*   **删除线** (`strikeThrough`)
*   **上标** (`superscript`)
*   **下标** (`subscript`)
*   **列表状态**: 检查 `insertOrderedList` 和 `insertUnorderedList`。

**B. 属性值 (Value States)**
*   **字体** (`fontName`): 优先取 `queryCommandValue`，失败取 `computedStyle.fontFamily`。
*   **前景色** (`foreColor`): 取 `queryCommandValue` 或 `computedStyle.color`。
*   **背景色** (`backColor`): 取 `queryCommandValue('hiliteColor')` 或 `computedStyle.backgroundColor`。
*   **字号** (`fontSize`): **双重捕获**。同时记录 `queryCommandValue` (1-7 级) 和 `computedStyle.fontSize` (px 值)，以便应用时更精确。

**C. 段落样式 (Block Styles)**
*   **对齐方式**: 依次检查 `justifyLeft`, `justifyCenter`, `justifyRight`, `justifyFull`。
*   **行高** (`lineHeight`): 通过 `computedStyle.lineHeight` 获取当前块级容器的行高。

---

### 2. 样式应用逻辑 (Application Logic)
当用户在激活状态下选择文本并释放鼠标时，按以下顺序应用样式：

1.  **对比应用基础格式**:
    *   遍历所有 Boolean States，对比 **当前选区状态** 与 **捕获状态**。
    *   仅当状态不一致时，执行 `execCommand` 进行切换（例如：源是粗体，目标不是，则执行 `bold`；反之亦然）。

2.  **应用对齐方式**:
    *   如果源有明确对齐方式，且与目标不一致，执行对应的 `justify` 命令。

3.  **应用属性值**:
    *   **颜色/字体**: 直接执行 `execCommand` 应用捕获的值。
    *   **背景色**: 优先使用 `hiliteColor` 命令（兼容性更好）。
    *   **字号**: **优先使用 px 值**。如果捕获了 px 值，调用 `applyCustomStyle('fontSize', px)`；否则回退到 `execCommand('fontSize', 1-7)`。

4.  **应用行高 (Block Style)**:
    *   调用独立的 `applyLineHeight` 函数。
    *   该函数会遍历选区的父节点，找到最近的块级元素 (P, DIV, H1-6, LI 等)，并设置 `style.lineHeight`。

5.  **交互反馈 (UX)**:
    *   **激活时**: 设置编辑器 `body` 的 `cursor` 为 `copy` (或类似样式)。
    *   **结束时**: 恢复 `cursor` 为 `text`，并清除激活状态。

---

### 3. 代码重构
*   将 `lineHeight` 的应用逻辑提取为 `applyLineHeight` 内部函数，供常规命令和格式刷复用。
*   修改 `useEditorCommands.ts` 实现上述所有逻辑。